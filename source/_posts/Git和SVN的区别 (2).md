---
title:版本控制之道-使用git（之一）
---

###### Git优势：

1. **分布式体系结构：**可以完全断网工作，不受网络连接的限制。

2. **分支与合并操作很容易：**创建分支简单、经济、快速，这与其他版本控制系统不一样。Git把分支上的所有修改合并回父分支，即使多次，也只是一眨眼的功夫。

3. **跟Subversion进行交互：**如果你是公司里唯一打算使用Git的人，其他人仍然在使用Subversion，不要担心。Git可以从Subversion的版本库中导入所有的历史，并把你在Git中的改动发送回Subversion的版本库。

   ------

#### 第一节：版本库

###### 版本库：

版本库是版本控制系统用来存储所有历史数据的地方。大部分存储各个文件的当前状态、历史修改时间、谁做的修改、以及修改的原因。

听到一个好玩的比喻，版本控制系统就好比是银行保险箱，而他所保存的历史信息就好比对账单。每当存入一笔存款时，或者说是每当进行一次提交的时候，版本控制系统就会在“对账单”上添加一个条目，并且把提交的内容保存到版本库里。

###### 集中式版本库模式：

比如SVN：这类版本库控制系统允许程序猿通过网络来获取版本库中的代码，并在修改后提交回来。在这种模式中，所有的程序猿都会把他们的改动提交到服务器上的一个公共版本库中。具体来说，每个程序猿在本地有一个工作目录树，其内容是该版本库中最新的代码。当他们在工作目录树中完成代码修改后，就把改动提交回该版本库中。

这种方式的局限性。首先，在本地工作目录树中，只能看到代码的最新版本。如果想查询历史修改记录，就必须与服务器上的版本库打交道。这就带来另一个问题：同远程的版本库链接，通常需要使用网络。

###### 分布式版本控制系统：

与传统版本控制系统的区别在于，开发人员相互同步修改内容的方式不同。

以Git为代码的分布式版本控制系统最大的优势是，每个人都会在本地有自己的版本库，而不是连接到服务器上的一个公共的版本库。所有的历史记录都存储在本地的版本库中。向版本库提交代码无需连接远程版本库，而是记录在本地的版本库中。

*PS：这里有个疑问，不知道修改版本差异大的话，提交的时候解决冲突是不是很麻烦？（之后再回来看这个问题）*

集中式版本控制就好比是程序员们公用一个保险箱。而分布式版本控制系统就好像是每个程序猿都有他自己的个人保险箱。

那么，在分布式版本控制系统中，程序猿之前如何传递各自的修改，如何同步呢？程序猿还是将修改上传到项目主版本库。有两种实现方法：可以通过Git的Push操作直接把修改上传到主版本库，也可以生成包含少量修改的补丁包，把补丁包提交给项目维护人员，再由项目维护人员更新主版本。

**<u>小结：</u>**

**<u>SVN是集中式版本控制方式；Git是分布式版本控制方式。</u>**

**<u>集中式版本控制方式是所有人公用服务器上的一个公共版本库，每人本地有一个工作目录树，内容为公共版本库中的最新代码。更新和提交和查看版本记录等操作都需要通过网络。</u>**

**<u>分布式版本控制方式是每人都会在本地有自己的版本库。所有的历史记录都存储在本地的版本库里。向版本库提交代码无需连接远程版本库，而是记录在本地的版本库中。</u>**

------

#### 第二节 版本库中存储什么

“如果没有某样东西，我能在这个项目中工作吗？”，如果答案是否定的，那么这样东西就需要纳入版本控制。

通常存储：源代码，配置文件样例，各类文档，程序中使用的图片，单元测试脚本，构建文件等。

构建文件，譬如 Makefile，build.xml等是需要放进去的。

工具类的，如Ant、JUnit。如果是为了保证大家使用相同版本，可以放。但最好也是和项目本身内容分开放。

**<u>小结：</u>**

<u>**判断某样东西是否需要纳入版本管理，那么要看如果没这样东西，我能在这个项目中工作吗？****</u>

<u>**工具类的文件也可以提交到版本控制中，但是最好和项目本身内容分开管理。**</u>

#### 第三节 工作目录树

定义：工作目录树是版本库的一个“断面视图”。包括开发该项目所需要的全部文件。一些版本控制系统把工作目录树成为工作拷贝（Working Copy），例如svn，工作目录在本地，版本库在服务器上。Git并非如此。

Git的版本库不在服务器上，而存储在本地工作目录树的".git"目录中。这意味着，要想知道历史消息，只和本地的版本库打交道即可，无需与服务器上的版本库通信。

工作目录树是怎么创建的呢？

1. 第一个方法是用Git相关的命令初始化版本库，也就是生成".git"目录，于是".git"目录的父目录就成了工作目录树。
2. 第二个方法是克隆（Clone）一个已有的版本库，也就连带创建了相应的工作目录树。

克隆一个已有的版本库，就是创建该版本库的一个拷贝，并把版本库中主分支（Master Branch）的内容检出到工作目录树。

#### 第四节 代码修改与文件同步

1. 每次提交操作都使得版本库中新增一个版本。此时除了内容本身的改动外，还记录改动的日志信息（或叫 提交留言），以便将来能很方便的查询为什么要做这个改动，并能够很方便的查找某个bug是何时引入的。 *PS：之前一直以为commit只是为了加一句提交日志，push才是提交。现在看来，commit就已经是提交了，push是推到远程仓库而已。*

2.  像Git这样的分布式版本控制系统，除了把改动提交到本地版本库之外，还要通过Push命令把改动推到上游版本库（公共版本库），以便其他程序猿能够得到。

   推入操作只完成了程序猿间代码同步工作的一半。另一半是，必须把别人完成的改动从公共版本库拿到本地版本库中来。

   具体来说，把远程版本库里的改动拿到本地版本库中，需要两步操作。第一步，把改动取来（Fetch），即把远程版本库中的版本和分支复制到本地版本库中。第二步，在本地版本库中，把远程版本库里取来的改动与自己本地的改动合并（Merge）。这两步相当于Pull（拖入）命令。拖入操作有点像是SVN中的updage操作。

   解释说明："本地版本库"是指执行Git操作所在的版本库。而"远程版本库"是"另外一个"版本库，他不一定要在远方的另一台计算机上，与"本地版本库"在同一台计算机上也可以。

   Git是完全分布式的。可以把本地版本库中所做的改动推入到不止一个远程版本库中，也可以把不止一个远程版本库中的改动拖到本地版本库中。

   #### 第五节 跟踪项目、目录和文件

   （2018.11.7 晚19:04）
